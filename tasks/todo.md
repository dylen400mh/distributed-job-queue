# Terraform: AWS Infrastructure

## Goal

Provision all AWS resources the k8s manifests and deploy workflow already reference:
RDS (PostgreSQL), ElastiCache (Redis), MSK (Kafka), ECR (two repos), EKS (cluster),
and the IAM wiring that connects GitHub Actions to AWS via OIDC.

---

## File Structure

```
terraform/
  providers.tf        # AWS provider + required_versions
  backend.tf          # S3 state bucket + DynamoDB lock table (remote state)
  variables.tf        # region, cluster_name, node instance types, db sizes
  outputs.tf          # All values the user needs to paste into GitHub Variables
  vpc.tf              # VPC, 3 public + 3 private subnets across 3 AZs, NAT gateways
  ecr.tf              # ECR repos: jq-server and jq-worker (image scan on push)
  iam.tf              # GitHub OIDC provider + CI/CD role, EKS node role
  security_groups.tf  # SGs for EKS nodes, RDS, Redis, MSK (least-privilege)
  eks.tf              # EKS cluster (K8s 1.30) + managed node group
  rds.tf              # RDS PostgreSQL 15, Multi-AZ, private subnets
  elasticache.tf      # ElastiCache Redis 7, private subnet group
  msk.tf              # MSK Kafka 3.6, 2 brokers, private subnets
  secrets.tf          # Secrets Manager: DB password (randomly generated by Terraform)
```

---

## Resources Summary

| Resource | Spec | Notes |
|---|---|---|
| VPC | 10.0.0.0/16, 3 AZs | Public subnets for NAT/LB, private for everything else |
| ECR (×2) | jq-server, jq-worker | Image scan enabled; lifecycle: keep last 10 images |
| EKS | K8s 1.30, t3.medium × 2–5 nodes | Managed node group, private subnets |
| RDS | PostgreSQL 15, db.t3.medium, 20 GB gp3 | Multi-AZ, automated backups 7 days |
| ElastiCache | Redis 7, cache.t3.micro | Single node (no cluster mode needed) |
| MSK | Kafka 3.6, kafka.t3.small × 2 brokers | Private subnets, no public access |
| IAM | GitHub OIDC provider + role | Scoped to this repo only; ECR + EKS permissions |
| Secrets Manager | `jq/db-password` | Random 32-char password; referenced in k8s Secret |

---

## Key Design Decisions

- **Flat files, no custom modules** — readable and easy to modify
- **DB password via Terraform random_password + Secrets Manager** — never hardcoded
- **GitHub OIDC** — role scoped to `repo:dylen400mh/distributed-job-queue:ref:refs/heads/main`
- **Private-only data plane** — RDS, Redis, MSK have no public endpoints; only accessible from EKS nodes
- **Parameterized instance types** — easy to switch dev → prod without code changes

---

## Setup Flow (after `terraform apply`)

1. `terraform output` prints all endpoints and cluster name
2. User sets GitHub Variables: `AWS_REGION`, `AWS_ACCOUNT_ID`, `EKS_CLUSTER_NAME`
3. User sets GitHub Secret: `AWS_ROLE_ARN` (from output)
4. Update `k8s/secret.yaml` with real endpoints (or use External Secrets Operator)
5. Push to main → deploy workflow runs

---

## Todo

- [x] 1. Create `terraform/providers.tf` and `terraform/backend.tf`
- [x] 2. Create `terraform/variables.tf` and `terraform/outputs.tf`
- [x] 3. Create `terraform/vpc.tf`
- [x] 4. Create `terraform/ecr.tf`
- [x] 5. Create `terraform/iam.tf` (GitHub OIDC + EKS node role)
- [x] 6. Create `terraform/security_groups.tf`
- [x] 7. Create `terraform/eks.tf`
- [x] 8. Create `terraform/rds.tf`
- [x] 9. Create `terraform/elasticache.tf`
- [x] 10. Create `terraform/msk.tf`
- [x] 11. Create `terraform/secrets.tf`
- [x] 12. Validate with `terraform validate` — passes clean
- [x] 13. Commit and push

---

## Review

All 11 Terraform files created and validated clean with `terraform validate`:

- **providers.tf / backend.tf** — AWS + random providers; S3 remote state with DynamoDB locking; includes bootstrap instructions
- **variables.tf / outputs.tf** — all instance types, sizes, and names parameterized; outputs print every value needed for GitHub Actions config
- **vpc.tf** — 10.0.0.0/16 VPC, 3 public + 3 private subnets across 3 AZs, per-AZ NAT gateways for HA
- **ecr.tf** — jq-server + jq-worker repos with image scanning and lifecycle policy (keep last 10)
- **iam.tf** — GitHub OIDC provider; CI/CD role scoped to main branch; EKS cluster + node roles with managed policies
- **security_groups.tf** — EKS node/control-plane SGs (cycle broken with `aws_security_group_rule`); RDS, Redis, MSK locked to EKS nodes only
- **eks.tf** — EKS 1.30 cluster in private subnets with control plane logging; managed node group 2–5 × t3.medium
- **rds.tf** — PostgreSQL 15, Multi-AZ, gp3, 7-day backups, deletion protection
- **elasticache.tf** — Redis 7, single node cache.t3.micro in private subnet group
- **msk.tf** — Kafka 3.6, 2 brokers kafka.t3.small, JMX/node exporter enabled
- **secrets.tf** — random_password 32 chars → Secrets Manager `jq/db-password`
